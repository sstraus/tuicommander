# Implementation Plan: Activity Center & Plugin System

**Created:** 2026-02-21
**Status:** Draft
**Estimated Effort:** L

## Summary

Transform the bell dropdown from a PR-only notification widget into a generic **Activity Center** that aggregates items from multiple sources. PR notifications remain a native first-class store; plans, stories, and future data sources become **plugins** that watch PTY output, extract data, and contribute items with virtual markdown content (generated by the plugin, not read from filesystem).

A "last item" shortcut button to the left of the bell shows the most recently added item from any source — giving instant context on what just happened.

## Architecture

```
Bell Dropdown (UI — Toolbar.tsx)
├── PR UPDATES section ─────── reads from prNotificationsStore (unchanged)
├── PLAN section ────────────── reads from activityStore (plan plugin)
└── STORIES section ─────────── reads from activityStore (stories plugin)

"Last Item" Button (UI — Toolbar.tsx)
└── shows most recent item across prNotificationsStore + activityStore

Plugin System
├── pluginRegistry ──── manages plugin lifecycle, dispatches PTY lines
├── activityStore ───── holds plugin-contributed items (sections + items)
├── markdownProviderRegistry ── resolves virtual content URIs
│
├── plan-plugin ─── listens for pty-parsed plan-file events
├── stories-plugin ── watches PTY output for story patterns
└── (future plugins)

PTY Pipeline (Terminal.tsx) — integrated, not parallel
├── handlePtyData(data) — single entry point
│   ├── pluginRegistry.processRawOutput(data, sessionId)  ← LineBuffer + stripAnsi + dispatch
│   ├── terminal.write(data)                               ← existing
│   └── activity flags, idle detection, backpressure       ← existing
│
├── pty-parsed events — structured events from Rust OutputParser
│   ├── switch/case for terminal state (progress, rate-limit, etc.) ← existing, unchanged
│   └── pluginRegistry.dispatchStructuredEvent(parsed, sessionId)   ← plugins hook here
│
├── Rust handles: rate-limit, progress, status-line, question, usage-limit (stable)
└── TS plugins handle: stories, memory, future dynamic patterns (extensible)
```

### Key Decisions

| Decision | Choice | Rationale |
|---|---|---|
| PR notifications | Stay as native store | Not a plugin — different lifecycle, already works well |
| Plugin model | Obsidian-style onload/onunload + Disposable | Simple, no process isolation needed for first-party code |
| Sandboxing | None (trusted TS modules) | All plugins are first-party, compiled with the app |
| Output interception | Before terminal.write() via LineBuffer | Can't block PTY path; strip ANSI before matching |
| Virtual content | URI scheme registry (VS Code pattern) | `plan:file?path=...`, `stories:detail?id=042` |
| Plugin items | Stored in activityStore | Separate from prNotificationsStore — different sources, same bell UI |

## Data Types

### Activity Item (plugin-contributed)

```typescript
interface ActivityItem {
  id: string;
  pluginId: string;         // which plugin created this
  sectionId: string;        // section to group into
  title: string;            // main text (larger)
  subtitle?: string;        // secondary text (smaller)
  icon: string;             // inline SVG string
  iconColor?: string;       // CSS color
  dismissible: boolean;
  createdAt: number;
  contentUri?: string;      // "plan:file?path=...", resolved by markdownProviderRegistry
  onClick?: () => void;     // alternative to contentUri
}

interface ActivitySection {
  id: string;
  label: string;            // "PLAN", "ACTIVE STORIES"
  priority: number;         // render order (lower = higher in dropdown)
  canDismissAll: boolean;
}
```

### Plugin Interfaces

```typescript
interface TuiPlugin {
  id: string;
  onload(host: PluginHost): void;
  onunload(): void;
}

interface PluginHost {
  registerSection(section: ActivitySection): Disposable;
  registerOutputWatcher(watcher: OutputWatcher): Disposable;
  registerStructuredEventHandler(
    type: string,
    handler: (payload: unknown, sessionId: string) => void
  ): Disposable;
  registerMarkdownProvider(scheme: string, provider: MarkdownProvider): Disposable;
  addItem(item: Omit<ActivityItem, "createdAt">): void;
  removeItem(id: string): void;
  updateItem(id: string, updates: Partial<ActivityItem>): void;
}

interface OutputWatcher {
  pattern: RegExp;
  onMatch: (match: RegExpExecArray, sessionId: string) => void;
}

interface MarkdownProvider {
  provideContent(uri: URL): string | Promise<string>;
}

interface Disposable {
  dispose(): void;
}
```

### Bell "Last Item" Computation

```typescript
// Computed from both stores — shows the most recently created item
function getLastInserted(): { title: string; icon: string; onClick?: () => void } | null {
  const lastPr = prNotificationsStore.getActive()
    .sort((a, b) => b.createdAt - a.createdAt)[0];
  const lastPlugin = activityStore.getLastItem();

  if (!lastPr && !lastPlugin) return null;
  if (!lastPr) return adaptPluginItem(lastPlugin!);
  if (!lastPlugin) return adaptPrItem(lastPr);
  return lastPr.createdAt > lastPlugin.createdAt
    ? adaptPrItem(lastPr) : adaptPluginItem(lastPlugin);
}
```

### Virtual Markdown Tab

Extend `MdTabData` to support virtual content alongside file-based content:

```typescript
// Current:
interface MdTabData {
  id: string;
  repoPath: string;
  filePath: string;
  fileName: string;
}

// New — discriminated union:
type MdTabData =
  | { id: string; type: "file"; repoPath: string; filePath: string; fileName: string }
  | { id: string; type: "virtual"; title: string; contentUri: string };
```

`MarkdownTab` resolves virtual tabs via `markdownProviderRegistry.resolve(contentUri)` instead of `repo.readFile()`.

## Implementation Order (TDD)

### Step 1: Core Types & Utilities

- **Test:** `src/__tests__/utils/lineBuffer.test.ts` — chunk splitting, partial lines, empty input, multi-byte
- **Test:** `src/__tests__/utils/stripAnsi.test.ts` — SGR codes, OSC sequences, cursor movement, clean passthrough
- **Implement:** `src/utils/lineBuffer.ts` — LineBuffer class
- **Implement:** `src/utils/stripAnsi.ts` — ANSI stripping regex
- **Implement:** `src/plugins/types.ts` — all shared interfaces (ActivityItem, ActivitySection, TuiPlugin, PluginHost, OutputWatcher, MarkdownProvider, Disposable)
- **Validation:** Unit tests pass, types compile

### Step 2: Activity Store

- **Test:** `src/__tests__/stores/activityStore.test.ts`
  - registerSection: adds section, returns Disposable that removes it
  - addItem / removeItem / updateItem: CRUD on items
  - getActive: returns non-dismissed items
  - getForSection: filters by sectionId
  - getLastItem: returns most recently created item
  - dismissItem / dismissSection: dismiss by id or section
  - clearAll: reset for testing
- **Implement:** `src/stores/activityStore.ts`
- **Validation:** All store tests pass

### Step 3: Markdown Provider Registry

- **Test:** `src/__tests__/plugins/markdownProviderRegistry.test.ts`
  - register: adds provider for a scheme, returns Disposable
  - resolve: routes URI to correct provider
  - resolve: returns null for unknown scheme
  - resolve: handles async providers
  - dispose: unregisters provider
- **Implement:** `src/plugins/markdownProviderRegistry.ts`
- **Validation:** Registry tests pass

### Step 4: Plugin Registry & PluginHost

- **Test:** `src/__tests__/plugins/pluginRegistry.test.ts`
  - register/unregister plugin lifecycle (onload/onunload called)
  - registerSection delegates to activityStore
  - registerOutputWatcher: adds watcher, dispatchLine calls onMatch
  - registerStructuredEventHandler: dispatchStructuredEvent routes correctly
  - registerMarkdownProvider: delegates to markdownProviderRegistry
  - addItem/removeItem/updateItem: delegate to activityStore
  - dispatchLine: ANSI already stripped by caller, dispatches to all watchers
  - dispatchLine: catches exceptions from watchers (never throws)
  - dispatchLine: resets lastIndex on global regexes
- **Implement:** `src/plugins/pluginRegistry.ts`
- **Depends on:** Steps 2, 3
- **Validation:** Plugin registry tests pass

### Step 5: Virtual Markdown Tab

- **Test:** `src/__tests__/stores/mdTabs.test.ts` — extend existing tests:
  - addVirtual(title, contentUri): creates virtual tab
  - addVirtual with same contentUri: returns existing tab (dedup)
  - remove: works for both file and virtual tabs
  - getActive: returns correct type
- **Test:** Update `src/__tests__/components/MarkdownTab.test.tsx` (if exists):
  - virtual tab renders content from markdownProviderRegistry
  - virtual tab shows loading state while resolving
  - virtual tab handles resolution errors
- **Implement:** Extend `src/stores/mdTabs.ts` — MdTabData discriminated union, `addVirtual()` action
- **Implement:** Update `src/components/MarkdownTab/MarkdownTab.tsx` — branch on tab type, resolve virtual content
- **Depends on:** Step 3
- **Validation:** Existing mdTabs tests still pass + new virtual tab tests pass

### Step 6: Integrate Plugin Dispatch into Existing PTY Pipeline

**Key principle:** No parallel processing paths. The plugin dispatch is integrated INTO the existing flow.

```
handlePtyData(data)
├── pluginRegistry.processRawOutput(data, sessionId)  ← NEW
├── terminal.write(data)                               ← existing
├── activity flags, idle detection                     ← existing

pty-parsed events
├── switch/case for terminal state                     ← existing, unchanged
├── pluginRegistry.dispatchStructuredEvent()            ← NEW (after switch)
```

- **Implement:** In `src/components/Terminal/Terminal.tsx`:
  - In `handlePtyData()`: call `pluginRegistry.processRawOutput(data, sessionId)` BEFORE `terminal.write(data)`. processRawOutput internally manages LineBuffer + stripAnsi + dispatch to registered OutputWatchers.
  - In the `pty-parsed` event handler: AFTER the existing switch/case (which handles terminal state like progress, rate-limit, etc.), add `pluginRegistry.dispatchStructuredEvent(parsed, sessionId)` so plugins can react to Rust-parsed events.
  - `plan-file` case stays in the switch/case for now (removed in Step 10 when plan plugin takes over).
- **Note:** Stable patterns (rate-limit, progress, question) stay in Rust OutputParser. Dynamic/extensible patterns (stories, future plugins) use TS-side watchers. No duplication.
- **Depends on:** Step 4
- **Validation:** Existing terminal tests still pass, no regressions, no behavior change

### Step 7: Plan Plugin

- **Test:** `src/__tests__/plugins/planPlugin.test.ts`
  - onload: registers "plan" section, structured event handler, markdown provider
  - On plan-file event: adds ActivityItem to activityStore
  - On plan-file event with same path: deduplicates
  - MarkdownProvider: resolves plan:file URI by reading file content
  - onunload: cleans up all registrations
  - dismissing plan item: removes from activity store
- **Implement:** `src/plugins/planPlugin.ts`
  - Registers section: `{ id: "plan", label: "PLAN", priority: 10, canDismissAll: false }`
  - Handles structured event type "plan-file"
  - Registers markdown provider for "plan" scheme: reads file via `invoke("read_file", { path })`
  - ActivityItem: title = plan display name, subtitle = repo path, icon = document SVG, contentUri = `plan:file?path=...`, dismissible = true
- **Depends on:** Step 4
- **Validation:** Plan plugin tests pass

### Step 8: Wiz Stories Plugin

- **Test:** `src/__tests__/plugins/wizStoriesPlugin.test.ts`
  - onload: registers "stories" section, output watchers, markdown provider
  - Pattern match: detects story work patterns in PTY output
  - On match: adds ActivityItem with title = story title, subtitle = story id/tags
  - MarkdownProvider: reads story JSON file, formats as markdown
  - onunload: cleans up
  - Multiple stories: each gets its own item
- **Implement:** `src/plugins/wizStoriesPlugin.ts`
  - Registers section: `{ id: "stories", label: "STORIES", priority: 20, canDismissAll: false }`
  - Output patterns (validate exact patterns against actual wiz:stories output):
    - `/\[story[:\s]+(\S+)\]/i` or similar — needs validation of real CLI output
  - Registers markdown provider for "stories" scheme: reads JSON, formats markdown table
  - ActivityItem: title = story short title, subtitle = story id + status, icon = bolt SVG
- **Depends on:** Step 4
- **Note:** Story detection patterns need validation against actual wiz:stories CLI output format. Placeholder patterns will be refined during implementation.
- **Validation:** Stories plugin tests pass

### Step 9: Bell UI Refactor (Toolbar.tsx)

- **Test:** Update `src/__tests__/components/Toolbar.test.tsx`:
  - Bell shows when any source has active items (PR or plugin)
  - Badge count = PR active count + plugin active count
  - Dropdown renders PR section when PRs exist
  - Dropdown renders plugin sections when plugin items exist
  - Sections show in priority order
  - "Dismiss All" per section works
  - Individual dismiss works
  - Clicking PR item opens PrDetailPopover (unchanged)
  - Clicking plugin item with contentUri opens virtual markdown tab
  - "Last item" button: hidden when no items anywhere
  - "Last item" button: shows most recent item across all sources
  - "Last item" button click: performs item action
  - Plan button no longer exists (replaced by plugin)
  - Remove `onOpenPlan` prop
- **Implement:** Refactor `src/components/Toolbar/Toolbar.tsx`:
  - Remove plan button entirely
  - Replace PR-specific bell with generic bell:
    - Reads from both prNotificationsStore (native) and activityStore (plugins)
    - Renders sections: each plugin section + "PR UPDATES" section
    - Each section has header + items + optional dismiss-all
  - Add "last item" shortcut button (left of bell):
    - Shows icon + truncated title of most recently created item across all sources
    - Click performs the item's action
    - Only visible when items exist
  - NOTIFICATION_LABELS stays for PR items (unchanged)
  - Keep PrDetailPopover integration for PR item clicks
- **Depends on:** Steps 2, 5, 7
- **Validation:** Updated toolbar tests pass

### Step 10: Wiring & Cleanup

- **Implement:** `src/plugins/index.ts` — exports all built-in plugins + initialization function
- **Implement:** Update `src/App.tsx`:
  - Import and initialize pluginRegistry at app startup
  - Register built-in plugins (plan, stories)
  - Remove `onOpenPlan` callback (plan opens via plugin → virtual markdown tab now)
  - Add handler for virtual markdown tab opening from activity items
- **Implement:** Update `src/stores/ui.ts`:
  - Remove `planFilePath`, `setPlanFilePath`, `clearPlanFile` (handled by plan plugin now)
- **Implement:** Update `src/components/Terminal/Terminal.tsx`:
  - Remove direct `uiStore.setPlanFilePath(parsed.path)` in plan-file case (plugin handles it now)
- **Implement:** Update `src/dev/simulator.ts`:
  - Plan simulation goes through pluginRegistry instead of uiStore
- **Depends on:** Steps 6, 7, 8, 9
- **Validation:** Full test suite passes, no uiStore.planFilePath references remain

### Step 11: CSS Updates

- **Implement:** Update `src/styles.css`:
  - Rename `.pr-notif-*` classes to `.activity-*` (generic naming)
  - Add `.activity-section-header` for section dividers with labels
  - Add two-line item layout: `.activity-item-title` (larger) + `.activity-item-subtitle` (smaller)
  - Add `.activity-last-item` button styles (matches plan-button-group pattern but generic)
  - Keep type-specific icon colors for PR items (`.notif-merged`, `.notif-ready`, etc.)
  - Remove `.plan-button-*` classes (no longer used)
- **Validation:** Visual verification via screenshot

### Final: Documentation & Cleanup

- [ ] Update `docs/FEATURES.md` with Activity Center feature
- [ ] Update `src/components/HelpPanel/HelpPanel.tsx` if bell behavior changes
- [ ] Update `SPEC.md` feature status
- [ ] Remove TODOs
- **Validation:** Lint clean, all tests pass

## Related Files

### New Files
| File | Purpose |
|---|---|
| `src/plugins/types.ts` | Shared interfaces |
| `src/plugins/pluginRegistry.ts` | Plugin lifecycle + dispatch |
| `src/plugins/markdownProviderRegistry.ts` | Virtual content resolution |
| `src/plugins/planPlugin.ts` | Plan file detection plugin |
| `src/plugins/wizStoriesPlugin.ts` | Wiz stories detection plugin |
| `src/plugins/index.ts` | Built-in plugin registration |
| `src/stores/activityStore.ts` | Plugin-contributed items store |
| `src/utils/lineBuffer.ts` | PTY chunk → line buffering |
| `src/utils/stripAnsi.ts` | ANSI code stripping |

### Modified Files
| File | Changes |
|---|---|
| `src/components/Toolbar/Toolbar.tsx` | Generic bell, last-item button, remove plan button |
| `src/components/MarkdownTab/MarkdownTab.tsx` | Handle virtual content tabs |
| `src/stores/mdTabs.ts` | Discriminated union for file vs virtual tabs |
| `src/stores/ui.ts` | Remove planFilePath state |
| `src/components/Terminal/Terminal.tsx` | Add PTY interception for plugins |
| `src/App.tsx` | Plugin initialization, remove onOpenPlan |
| `src/dev/simulator.ts` | Update plan simulation |
| `src/styles.css` | Rename PR-specific to generic, add section styles |

### Test Files
| File | Status |
|---|---|
| `src/__tests__/utils/lineBuffer.test.ts` | New |
| `src/__tests__/utils/stripAnsi.test.ts` | New |
| `src/__tests__/stores/activityStore.test.ts` | New |
| `src/__tests__/plugins/markdownProviderRegistry.test.ts` | New |
| `src/__tests__/plugins/pluginRegistry.test.ts` | New |
| `src/__tests__/plugins/planPlugin.test.ts` | New |
| `src/__tests__/plugins/wizStoriesPlugin.test.ts` | New |
| `src/__tests__/components/Toolbar.test.tsx` | Updated |
| `src/__tests__/stores/prNotifications.test.ts` | Unchanged |

## Acceptance Criteria

- [ ] Bell dropdown shows sections from both PR notifications (native) and plugin items
- [ ] "Last item" button shows the most recently added item from any source
- [ ] Plan detection works via plugin (no more uiStore.planFilePath)
- [ ] Clicking a plugin item opens virtual markdown content (not file-based)
- [ ] Stories detection works via plugin with PTY pattern matching
- [ ] PTY output is not blocked by plugin pattern matching (< 1ms per line)
- [ ] All existing PR notification behavior preserved (auto-dismiss, focus timer, etc.)
- [ ] New plugin can be added by implementing TuiPlugin interface + registering in index.ts
- [ ] All tests pass including new plugin tests
- [ ] CSS classes use generic naming (activity-*) not PR-specific

## Security Considerations

- Plugins are trusted first-party TypeScript modules — no sandboxing needed
- Plugin watcher errors are caught and logged, never propagate to block PTY rendering
- Content URIs are resolved via registered providers only — no arbitrary file access

## Performance Considerations

- LineBuffer + stripAnsi + pattern dispatch must complete in < 1ms per PTY line
- Regex patterns must not use global flag (lastIndex reuse causes bugs)
- Async work (file reads, markdown generation) happens outside the dispatch hot path
- activityStore uses SolidJS fine-grained reactivity — bell only re-renders when items change

## Open Questions

- **Story detection patterns**: need to validate against actual wiz:stories CLI output. Placeholder regex in the plan — will refine during implementation.
- **Max items per section**: should there be a cap to prevent the dropdown from growing unbounded? Suggest 20 items per section with "show more" link.
- **Persistence**: plugin items are currently ephemeral (in-memory). If we want stories to survive a page reload, we'd need to persist the activityStore. Defer to a follow-up.

---

## Next Steps

When ready to implement, run:
- `/wiz:work plans/activity-center-plugin-system.md` - Execute the plan
- `/wiz:deepen-plan` - Get more detail on specific sections
- `/wiz:brainstorming` - discuss the plan details
